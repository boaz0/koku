# This file has two main sections:
# partition_targets
# stored_procedures
#
# If it exists, stored_procedures will be applied first
# To apply to all schemata, use "*" for the partition or strored_procedure items
# To omit a schema from either, then list it as <schema>: {}
#
# To make a new primary key, use the primary_key item in partition_targets section.
# You can add existing columns to a new key or create columns or override a column
# definition. To copy an existing sequence, use copy_sequence: 1. To create a new
# sequence, specify all sequence options in a section under new_sequence. To omit
# a new sequence, use new_sequence: {}.
#
# You can set a trigger on the partitioned table using the trigger section.
#
# When copying data from the original table, you can specify a column map from
# which to build the statement to perform the copy. This should resolve to a dict
# with the key being the partitioned table column and the value being the source
# table column.
partition_targets:
  '*':
    reporting_ocpusagelineitem_daily_summary:
      drop_table: 1
      primary_key:
        usage_start: {}
        id:
          copy_sequence: 1
      triggers: []
      partition_key: usage_start
      partition_type: range
      range:
        interval: 1
        interval_type: month
      copy_column_map: {}
  public: {}
stored_procedures:
  "*":
    depends_on_schema: public
    code: []
  public:
    code:
      - |-
        DROP PROCEDURE IF EXISTS {schema_name}.create_date_partitions(text, text, text, text, text, boolean);
        CREATE OR REPLACE PROCEDURE {schema_name}.create_date_partitions(
            check_table text,
            check_col text,
            schema text,
            partitioned_table text,
            partition_key text,
            _commit boolean DEFAULT false
        ) AS $$
        DECLARE
            rec record;
            partition_name text  = '';
            check_stmt text = '';
            action_stmt text = '';
        BEGIN
            check_stmt = 'WITH distinct_date_key as (' ||
                         'SELECT DISTINCT ' ||
                         '       to_char(' || quote_ident(check_col) || ', ''YYYY-MM-01'')::text as date_key' ||
                         '  FROM ' || quote_ident(check_table) || ' ' ||
                         ') ' ||
                         'SELECT ddk.date_key::date' ||
                         '  FROM distinct_date_key as ddk ' ||
                         ' WHERE NOT EXISTS (SELECT 1 ' ||
                         '                     FROM ' ||
                                                    quote_ident(schema) || '."partitioned_tables" ' ||
                         '                    WHERE schema_name = ' || quote_literal(schema) ||
                         '                      AND partition_of_table_name = ' || quote_literal(partitioned_table) ||
                         '                      AND partition_type = ''range'' ' ||
                         '                      AND ddk.date_key = (partition_parameters->>''from'') ) ;';
            FOR rec IN EXECUTE check_stmt
            LOOP
                -- Create the new partition
                partition_name = partitioned_table || '_' || to_char(rec.date_key, 'YYYY_MM');

                action_stmt = 'CREATE TABLE ' ||
                               quote_ident(schema) || '.' || quote_ident(partition_name) ||
                             ' PARTITION OF ' ||
                               quote_ident(schema) || '.' || quote_ident(partitioned_table) ||
                             ' FOR VALUES FROM (' ||
                               quote_literal(rec.date_key) ||
                              '::date) TO (' ||
                               quote_literal((rec.date_key + '1 month'::interval)::date) ||
                               '::date); ';
                EXECUTE action_stmt;

                -- log the new partition
                action_stmt = 'INSERT INTO ' || quote_ident(schema) || '."partitioned_tables" ( ' ||
                              '    "schema_name", "table_name", "partition_of_table_name", ' ||
                              '    "partition_type", "partition_col", "partition_parameters" ' ||
                              ') VALUES ( ' ||
                                  quote_literal(schema) || ', ' ||
                                  quote_literal(partition_name) || ', ' ||
                                  quote_literal(partitioned_table) || ', ' ||
                                  quote_literal('range') || ' ,' ||
                                  quote_literal(partition_key) || ', ' ||
                                 'jsonb_build_object( ' ||
                                 '    ''default'', false, ' ||
                                 '    ''from'', ' || quote_literal(rec.date_key::text) || ', ' ||
                                 '    ''to'', ' || quote_literal((rec.date_key + '1 month'::interval)::date::text) ||
                                 ' ));';
                EXECUTE action_stmt;
                END LOOP;

            IF (_commit = true) AND (action_stmt != '')
            THEN
                COMMIT;
            END IF;
        END;
        $$ LANGUAGE PLPGSQL;
